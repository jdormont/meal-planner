/*
  # Create Weekly Planner Tables

  1. New Tables
    - `weekly_meal_sets`
      - Stores the AI-curated weekly meal selections
      - `id` (uuid, pk)
      - `week_start_date` (date, unique)
      - `recipes` (jsonb) - Array of 5 recipe objects
      - `created_at` (timestamptz)
    
    - `meal_feedback`
      - Stores user feedback on specific recipes
      - `id` (uuid, pk)
      - `user_id` (uuid, fk to auth.users)
      - `recipe_id` (uuid, optional fk to recipes if it exists in DB, but might be from suggested so maybe just store ID/Name?)
      - The plan said "recipe_id: UUID", but suggested recipes might not be in the `recipes` table yet if they are just suggestions?
      - Wait, the carousel "Add to My Week" *adds* them to `meals`.
      - But the feedback might be on the *suggestion* itself.
      - If the suggestion is just a JSON object in `weekly_meal_sets`, it doesn't have a stable `recipe_id` in the `recipes` table unless we insert them all first.
      - `weekly_meal_sets` stores `recipes` as JSONB. These objects should have some ID?
      - The `RecipeResponseSchema` doesn't strictly force an ID.
      - Let's assume we generate a UUID for them or key off the title? No, title changes.
      - Actually, `suggested_recipes` table exists. Maybe the weekly curator inserts into `suggested_recipes` AND `weekly_meal_sets`?
      - The plan says: "Output: Insert row into `weekly_meal_sets`".
      - The plan also says: "Feedback... Calls feedback API".
      - Let's start `meal_feedback` with `recipe_identifier` (text) which could be UUID or Title, OR more robustly:
      - The `weekly_meal_sets.recipes` array items *should* probably have an ID generated by the AI or the system.
      - Let's stick to `recipe_id` (uuid) but make it nullable FK, or just UUID.
      - Plan says: `recipe_id: UUID (FK)`. FK to `recipes`?
      - If the weekly set are just *suggestions*, they aren't in `recipes` table until a user saves them.
      - So `recipe_id` here should probably be the `id` from `suggested_recipes` if we store them there, OR we just store `recipe_data` copy?
      - Re-reading plan: "`weekly_meal_sets`... `recipes`: JSONB or array of UUIDs".
      - If it's JSONB, we don't have FKs.
      - If we want to track feedback properly, we need to know *what* they are rating.
      - Let's use `target_id` (text) to store whatever ID we give the card (could be the recipe ID if it exists, or a suggestion ID).
      - Actually, the cleanest way is for the Weekly Job to insert the 5 recipes into `suggested_recipes` first, get their IDs, and then store those IDs in `weekly_meal_sets`.
      - `suggested_recipes` table has `id`, `user_id`... wait. `suggested_recipes` is per-user?
      - `weekly_meal_sets` is GLOBAL (one set for everyone, or at least the "Newsletter" implies a broadcast model).
      - "Weekly AI agent job to assemble five unique meals... dispatched via Sunday email".
      - If it's a global newsletter, the recipes need to be global?
      - Or is it per-user?
      - "Persona 1... I want fresh meal ideas...".
      - "Automatic Meal Curation... AI agent selects five meals weekly, ensuring variety and excluding recent repeats".
      - "Automated Sunday morning email...".
      - Usually these newsletters are personalized if they use AI.
      - REQUIRED: "Excluding recent repeats...". This implies PERSONALIZATION (User A's repeats != User B's repeats).
      - So `weekly_meal_sets` should probably be PER USER?
      - Plan says: "`weekly_meal_sets`... `id`, `week_start_date`...". It didn't specify `user_id`.
      - BUT `suggested_recipes` is per user.
      - If it's per user, we need `user_id` in `weekly_meal_sets`.
      - Let's check `weekly_planner.md`: "A weekly, AI-powered selection... specific to the user? ... excluding recent repeats in the last five weeks".
      - Yes, it MUST be per user.
      - So `weekly_meal_sets` needs `user_id`.
    
  2. Security
    - Enable RLS
    - Users can view/create their own weekly sets (or service role creates them).
*/

create table if not exists weekly_meal_sets (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete cascade not null,
  week_start_date date not null,
  recipes jsonb not null default '[]'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, week_start_date)
);

create table if not exists meal_feedback (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete cascade not null,
  target_id text not null, -- Can be recipe_id or suggestion_id
  target_type text not null check (target_type in ('recipe', 'suggestion')),
  rating text not null check (rating in ('thumbs_up', 'thumbs_down')),
  details jsonb default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for weekly_meal_sets
alter table weekly_meal_sets enable row level security;

create policy "Users can view their own weekly meal sets"
  on weekly_meal_sets for select
  using (auth.uid() = user_id);

create policy "Users can insert their own weekly meal sets" -- Mostly for testing/dev, usually service role checks this?
  on weekly_meal_sets for insert
  with check (auth.uid() = user_id);

-- RLS for meal_feedback
alter table meal_feedback enable row level security;

create policy "Users can view their own feedback"
  on meal_feedback for select
  using (auth.uid() = user_id);

create policy "Users can insert their own feedback"
  on meal_feedback for insert
  with check (auth.uid() = user_id);

-- Indexes
create index weekly_meal_sets_user_date_idx on weekly_meal_sets (user_id, week_start_date);
create index meal_feedback_user_target_idx on meal_feedback (user_id, target_id);
